// Se uno dei nuovi vertici si trova su un lato di un altro sottopoligono, lo aggiunge
                    // for (size_t tr = 0; tr < idtraces.size(); ++tr) {
                    //     if (tr != id_t) {
                    //         traceverts = traces.TracesExtremesCoord[tr];
                    //         for (const Vector3d& vertex : newvertices) {
                    //             if (abs(distance(vertex,traceverts[0])+distance(vertex,traceverts[1])
                    //                     -distance(traceverts[0], traceverts[1])) <= 1e-6) {
                    //                 for (size_t cp = 0; cp < sottopoligoni.size(); ++cp) {
                    //                     if (sottopoligoni[cp] != currentpolygon) {
                    //                         bool vertexadded = false;
                    //                         for (size_t l = 0; l < sottopoligoni[cp].size()-1; ++l) {
                    //                             if (abs(distance(vertex, sottopoligoni[cp][l])+distance(vertex, sottopoligoni[cp][l+1])
                    //                                     -distance(sottopoligoni[cp][l], sottopoligoni[cp][l+1])) >= 1e-6) {
                    //                                 if (!vertexadded) {
                    //                                     sottopoligoni[cp].push_back(vertex);
                    //                                     vertexadded = true;
                    //                                 }
                    //                             }
                    //                         }
                    //                         if (abs(distance(vertex, sottopoligoni[cp][sottopoligoni[cp].size()])+distance(vertex, sottopoligoni[cp][0])
                    //                                 -distance(sottopoligoni[cp][sottopoligoni[cp].size()], sottopoligoni[cp][0])) >= 1e-6) {
                    //                             if (!vertexadded) {
                    //                                 sottopoligoni[cp].push_back(vertex);
                    //                                 vertexadded = true;
                    //                             }
                    //                         }
                    //                         if (vertexadded) {
                    //                             antiorario(sottopoligoni[cp], fractures.Normals[id]);
                    //                         }
                    //                     }
                    //                 }
                    //             }
                    //         }
                    //     }
                    // }
