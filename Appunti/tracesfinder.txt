void tracesfinder(const Fractures& fractures, const list<vector<unsigned int>>& goodcouples, Traces& traces, const double& epsilon)
{
    Vector3d limit = {1e10,1e10,1e10};
    for(vector<unsigned int> couple : goodcouples)
    {
        unsigned int id1 = couple[0];
        unsigned int id2 = couple[1];
        Vector3d n1 = fractures.Normals[id1];
        Vector3d n2 = fractures.Normals[id2];
        Vector3d tangent = n1.cross(n2);
        if (tangent.norm() > epsilon) // Controlla che i piani non siano paralleli
        {
            double d1 = n1.dot(fractures.CoordVertices[id1][0]);
            double d2 = n2.dot(fractures.CoordVertices[id2][0]);
            double det = n1[0]*n2[1]-n1[1]*n2[0];
            double detx = -d1 * n2[1] + d2 * n1[0];
            double dety = -d1 * n2[1]+ d2 * n1[0];
            double detz = -d1 * n2[2] + d2 * n1[2];
            Vector3d point(detx/det, dety/det, detz/det);
            vector<Vector3d> intersections;
            Vector3d inter;
            for (size_t i = 0; i < fractures.CoordVertices[id1].size() - 1; ++i)
            {
                inter = Analytics::intersectrettaretta(point, tangent, fractures.CoordVertices[id1][i], fractures.CoordVertices[id1][i+1] - fractures.CoordVertices[id1][i]);
                if (inter != limit)
                {
                    intersections.push_back(inter);
                }
                // cout << inter(0) << ";" << inter(1) << ";" << inter(2) <<endl;
            }
            inter = Analytics::intersectrettaretta(point, tangent, fractures.CoordVertices[id1][fractures.CoordVertices[id1].size() - 1], fractures.CoordVertices[id1][0] - fractures.CoordVertices[id1][fractures.CoordVertices[id1].size() - 1]);
            if (inter != limit)
            {
                intersections.push_back(inter);
            }
            for (size_t i = 0; i < fractures.CoordVertices[id2].size() - 1; ++i)
            {
                inter = Analytics::intersectrettaretta(point, tangent, fractures.CoordVertices[id2][i], fractures.CoordVertices[id2][i+1] - fractures.CoordVertices[id2][i]);
                if (inter != limit)
                {
                    intersections.push_back(inter);
                }
            }
            inter = Analytics::intersectrettaretta(point, tangent, fractures.CoordVertices[id2][fractures.CoordVertices[id2].size() - 1], fractures.CoordVertices[id2][0] - fractures.CoordVertices[id2][fractures.CoordVertices[id2].size() - 1]);
            if (inter != limit)
            {
                intersections.push_back(inter);
            }
            cout << intersections.size() << endl;
            cout << id1 << "&" << id2 << ": ";
            for (Vector3d v : intersections)
            {
                for (unsigned int i = 0; i < v.size(); ++i)
                {
                    cout << v(i) << ";";
                }
                cout << "   ";
            }
            cout << endl;
        }
    }
}
