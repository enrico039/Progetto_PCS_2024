function antiorario:
conviene fare una void function e passare sottopol come modificabile. Si crea un vector<double> angoli che sarà della stessa dimensione di sottopol e poi si ordina sottopol usando sort:
vector<double>& angoli;
    sort(sottopol.begin(), sottpol.end(), [angoli]( unsigned int  a,  unsigned int  b)
         {
        return angoli[a] > angoli[b];
         });



function meshcalc:
nel calcolo di idtraces viene iterato su tutte le fratture e per due volte su tutte le tracce. conviene lanciare nella function printtips sort su traces.TipsTrue e traces.TipsFalse.
In questo modo in meshcalc basta iterare prima su tripstrue e poi su tipsfalse. Se si vuole togliere anche questa iterazione, basta aggiungere nella struct Traces una mappa che colleghi ogni frattura
al suo Id e riempirla in printtips quando si lancia il sort.
Si può considerare di memorizzare TipsTrue e TipsFalse come vector<pair<unsigned int, unsigned int>> in modo da poter chiamare .first e .second nel sorting.
In questo caso bisogna modificare la memorizzazione.

il ciclo che aggiunge i veritici alle fratture adiacenti appesantisce troppo il programma. Bisogna trovare una soluzione.

Si può inserire un test come quello delle sfere per escludere a priori senza usare intersect i sottopoligoni e le tracce troppo lontani tra loro.
